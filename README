sdi1900085 Δημόκριτος Κολίτσος

Compilation: make
Εκτέλεση: make run
Εναλακτικά εκτέλεση μπορεί να γίνει και με ./mysh μετά την εντολή make.
Στο makefile έχει συμπεριληφθεί και η δυνατότητα εκτέλεσης του προγράματος με valgrind τρεχοντας make valgrind
Με make clean καθαρίζονται όλα τα εκτελέσημα

documentation: για περισσότερες (η και λιγότερες απο θέμα ποσότητας γραπτού) λεπτομέριες υπάρχουν αναλυτικά comments
στον κώδικα

-Υλοποίηση του myShell γενικά:
Για την βασικη λειτουργεια του myshell αφού αρχικοποιήσω τις μεταβλητές που θα χρειαστώ μπαίνω σε μια infinite λούπα
μέσα στην οποία κάθε φορα εμφανίζω το "in-mysh-now:> " promt και έπειτα περιμένω τον χρήστη να πληκτρολογίσει κάποια
εντολή. Η εντολή του χρήστη αποθηκεύεται ως string και πρωτού περάσει για επεξεργασία την κρατάω στην δομή myHistory.
Έπειτα καλείται η parse_input που με την χρήση της strtok σπάει την εντολή σε λέξεις (arguments) για την ευκολότερη
επεξεργασία της. Το shell μπορεί επίσης να τερματιστεί με την εντολή exit. Θα γίνει έλενχος για τυχόν κλήση σχετικής
εντολής myHistory η οποία και εκτελείται στην ίδια συνάρτηση (cmd_history_check) και μετά, ανάλογα και με την
επιστροφή της cmd_history_check, θα κληθεί τελικά η execute_cmd η οποία είναι υπεύθυνη για την εκτέλεση της εντολής.

-execute_cmd:
Η execute_cmd είναι υπεύθυνη για την σωστή εκτέλεση της εντολής και την κλήση των υπόλοιπων συναρτήσεων που επιτρέπουν
την υποστήριξη παραπάνω λειτουργιών. Αρχικά κάνω fork και η διεργασία παιδι η οποία πρώτα καλεί τις συναρτήσεις piping
(για να γίνει έλεχνος για τυχόν υπάρχοντα pipes και την αναλογη επεξεργασία τους) και μετα, εφόσον δεν υπάρχουν pipes
και η συνάρτηση επιστρέψει, καλεί την io_redirection η οποία τακτοποιεί τυχόν ανακατευθύνσεις εισόδου/εξόδου από και
σε αρχεία. Τελικα η διεργασία παιδί θα αντικατασταθεί απ την execvp που θα τρέξει την κύρια εντολή. Άμα τερματίσει
επιτυχώς, η διεργασία γονέας που περίμενε τον τερματισμό της διεργασίας παιδιού θα επιτρέψει την επιστροφή απ την
συνάρτηση στην main έτσι ώστε το πρόγραμμα να προχωρίσει στον επόμενο κύκλο του. Σε περίπτωση που η execvp επιστρέψει
πίσω στο παιδί σημαίνει ότι κάτι πήγε στραβα με την εκτέλεση της και αφού εμφανιστεί το κατάληλο μήνυμα η διεργασία
παιδί τερματίζει με 1 και το πρόγραμμα συνεχίζει με τον ίδιο τρόπο.

a)Υποστήριξη Ανακατευθύνσεων
-io_redirection:
Η io_redirection αναλαμβάνει να διαχειριστεί τις ανακατευθύνσεις εισόδου/εξόδου από και προς αρχεία. Ελένχουμε 1-1
τα arguments της εντολής ψάχνοντας συγκεκριμένα για ">", ">>" ή  "<". Στην περίπτωση που βρεθεί:
    -">" ανοίγουμε το αρχείο που ακολουθεί με write only, να φτιαχεί άμα δεν υπάρχει αρχείο μ αυτό το όνομα και να
    γίνουν overwrite τα περιεχόμενά του άμα υπάρχει. Έπειτα με την dup2 κάνουμε duplicate τον file descriptor του
    αρχείου και μ αυτόν αντικαθιστάμε τον default file descriptor της stdout (και της stderr καθώς κάποια εντολή
    μπορεί να εκτυπώνει εκεί) έτσι ώστε τώρα οποιοδήποτε output προκαλέσει η εντολή να βγει στο συγκεκριμένο αρχείο.
    -">>" ανοίγουμε με τον ίδιο τρόπο το αρχείο που ακολουθεί μόνο που αντί για overwrite τώρα κάνουμε append,
    προσθέτουμε δηλαδή το output της εντολής στα περιεχόμενα του αρχείου.
    -"<" ανοίγουμε το αρχείο που ακολουθεί μόνο με το flag read only καθώς ο σκοπός μας εδώ είναι μόνο το διάβασμα
    των περιεχομένων του αρχείου (εφόσον υπάρχει) και η ανακατεύθηνσή τους με την dup2 στο stdin stream. Τα περιεχόμενα
    αυτά ενδέχονται μετα να χρησιμοποιηθούν στην εκτέλεση προγράματος ή κάποιας εντολής με την σειρά τους.
Τέλος και στις 3 περιπτώσεις κλείνουμε τον file descriptor καθώς δεν μας χρειάζεται πλεον και αφερούμε τα ">", ">>" ή  "<"
και το όνομα του αρχείου απ τα arguments για τον ίδιο λόγο.

b)Υποστήριξη σωληνώσεων (pipes)
-piping:
Η συνάρτηση piping έχει τον ρόλο υποστήριξης σωληνώσεων για το πρόγραμμα. Με τον ίδιο τρόπο όπως και στα redirects,
ψάχνουμε πρώτα τα args για "|". Άμα βρεθεί αρχικά το αφερούμε από τα args και μετά χωρίζουμε την εντολή σε 2 διαφορετικές
την αριστερή απ το pipe ή command 1 και την δεξιά απ το pipe η command 2. Έπειτα αφού αρχικοποιήσουμε την επικοινωνία
των 2 εντολών μέσα απ τους 2 pipe file descriptors κάνουμε fork και αναθέτουμε στην διεργασία παιδί (παιδί 2 γιατί 
θεωρητικά είμαστε ήδη στο παιδί 1 από την execute_cmd) την εντολή 1 ενώ ο γονέας αναλαμβάνει την εντολή 2. Η πρώτη
εντολή στη διεργασία παιδί θα κλείσει τον 1ο file descriptor που είναι το κομμάτι που διαβάζει (εφόσον δεν έχει
κάποια προιγούμενη διεργασία απ την οποία διαβάζει κάτι) και θα περάσει στην stdout (και stderr) τον 2ο fd που είναι
υπεύθυνος για το γράψημο. Μετά θα κλεισει και ο 2ος fd και άφου γίνει έλενχος για ανακατεύθηνσή εισόδου από και σε
αρχεία θα εκτελεστεί η εντολή 1 όπως και στην execute_cmd. Η αριστερή εντολή στην διεργασία γονέα κάνει το ακριβώς
αντίθετο και κλείνει πρώτα τον fd υπεύθυνο για γράψημο και παίρνει για stdin τον fd για το write κομμάτι του pipe
έτσι ώστε να λάβει τα αποτελέσματα της εντολής 1 ενώ μετα κ αυτή με τη σειρά της εκτελεί το υπόλοιπο κομμάτι της
εντολής όπως και η 1η. Αφού εκτελεστούν και οι 2 πια έχει τερματίσει και η διεργασία παιδί της execute_cmd οπότε και
συνεχίζει το προγραμμα.

g)Αποθήκευση ιστορικού (myHistory)
-myHistory struct:
Για την υλοποίηση του command history δημιουργώ ένα struct με έναν πίνακα απο strings που αποθηκεύονται οι εντολές,
newest command και oldest command indexes που δείχνουν στο τελευταίο κομαντ που αποθηκευτηκε και στο παλιότερο αντίστοιχα
και size που κρατάμε τον αριθμό των εντολών που έχουν αποθηκευτεί.
Το struct αρχικοποιήται στη main και χρησιμοποιείται στις save_cmd και cmd_history_check συναρτήσεις.
-save_cmd:
Εδώ γίνεται αποθήκευση κάθε εντολής που δίνει ο χρήστης στην string μορφή της (πριν γίνει parsed) με την βοήθεια της
μεταβλητής newest_cmd που κάθε φορά (+1 και αυτο διαέρεση με τον μέγιστο αριθμό εντολών που κρατάμε και παίρνουμε το υπόλοιπο
για να μην υπερβούμε τα όρια του πίνακα) μας δίνει έτοιμη την θέση αποθήκευσης της εντολής στον πίνακα. Η size μας βοηθάει
να ξέρουμε εάν έχουμε φτάσει στον μέγιστο αριθμό εντολών που μπορουμε να έχουμε αποθηκευμένες. Αν δεν έχουμε φτάσει ανανεώνουμε
την size αλλιώς εφόσον έγινε overwrite η προηγούμενη παλαιότερη εντολή ανανεώνουμε τον oldest_cmd indicator να δίχνει στην
τωρινή παλαιότερη εντολή.
-cmd_history_check:
Ελένχουμε εάν το πρώτο argument της εντολής είναι το myHistory. Εάν δεν είναι τότε επιστρέφουμε false έτσι ώστε η εντολή να
δοθεί στην execute_cmd. Εάν είναι όμως τότε θα διαχειριστούμε εδώ την εντολή. Άμα ο χρήστης έγραψε σκέτο myHistory τότε
εμφανίζουμε όλο το ιστορικό εντολών μέχρι στιγμής με την σειρά που έχουν δοθεί οι εντολές απο παλαιότερη σε πιο καινούρια
και προχωράμε (επιστρέφοντας true) στην λειτουργία του προγράμματος παρακάμτοντας την execute_cmd. Εάν ο χρήστης έχει δώσει
και αριθμό μαζί με την εντολή ο οποίος είναι νόμιμος (υπάρχει η αντίστοιχη αριθμιμένη εντολή στο history) τότε αφού τον
μετατρέψουμε σε int εμφανίζουμε την αντίστοιχη εντολή. Μετά εφόσον καθαρίσουμε τον cmd_args που κρατάει τα arguments της 
τωρινής εντολής	κάνουμε parse την εντολή που έχει ζητήσει ο χρήστης απ το history (αφού την δώσουμε πρώτα σε στην cmd_copy
string για να μην επιρεαστεί η ίδια η εντολή μέσα στο history απ την strtok της parse) και καλούμε αναδρομικά μ αυτήν την
cmd_history_check επιστρέφοντας το αποτελέσμά της. Εάν η εντολή ήταν σχετική με myHistory ακολουθούν ξανά τα παραπάνω αλλιώς
θα προχωρίσει στην execute_cmd για ναεκτελεστεί. 
